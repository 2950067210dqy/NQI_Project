# 界面优化和性能提升说明

## 📋 更新内容

### 1. **上位机 - 异步下载避免卡顿**

#### 问题
在主线程中下载文件会导致界面卡顿，影响用户体验。

#### 解决方案

✅ **添加下载线程类**

**电量数据下载线程：**
```python
class ExcelDownloadThread(QThread):
    """Excel 文件下载线程"""
    download_finished = pyqtSignal(str, str)  # file_path, device_id
    download_failed = pyqtSignal(str)  # error_message
    
    def run(self):
        """在后台线程执行下载"""
        self.client.download_excel_file(self.file_id, self.save_path)
        self.download_finished.emit(str(self.save_path), self.device_id)
```

**图片数据下载线程：**
```python
class ImageDownloadThread(QThread):
    """图片文件下载线程"""
    download_finished = pyqtSignal(str, str)  # file_path, device_id
    download_failed = pyqtSignal(str)  # error_message
    
    def run(self):
        """在后台线程执行下载"""
        self.client.download_image_file(self.file_id, self.save_path)
        self.download_finished.emit(str(self.save_path), self.device_id)
```

✅ **修改下载逻辑**

**之前（阻塞主线程）：**
```python
def on_new_data_received(self, data: dict):
    # ❌ 在主线程中下载，会卡顿
    self.server_client.client.download_excel_file(file_id, save_path)
    self.load_excel_file(save_path, device_id)
```

**之后（后台线程）：**
```python
def on_new_data_received(self, data: dict):
    # ✅ 在后台线程下载，不阻塞 UI
    download_thread = ExcelDownloadThread(client, file_id, save_path, device_id)
    download_thread.download_finished.connect(self.on_download_finished)
    download_thread.start()

def on_download_finished(self, file_path: str, device_id: str):
    # 下载完成后在主线程更新 UI
    self.load_excel_file(file_path, device_id)
```

**优点：**
- ✅ UI 不会卡顿
- ✅ 用户可以继续操作
- ✅ 支持多个文件同时下载
- ✅ 下载失败有错误提示

### 2. **几何量图片窗口 - 自动识别和显示优化**

#### 2.1 去除识别按钮

**之前：**
```python
# ❌ 需要手动点击识别按钮
self.recognize_btn = QPushButton("识别")
self.recognize_btn.clicked.connect(self.on_recognize_clicked)
```

**之后：**
```python
# ✅ 加载图片后自动识别
def load_original_image(self, image_path: Path):
    # 加载原图
    self.original_label.setPixmap(scaled_pixmap)
    
    # 自动识别
    self.auto_recognize()
```

#### 2.2 显示图片名称

**添加文件名标签：**
```python
# 每个显示区域添加文件名显示
self.filename_label = QLabel("--")
self.filename_label.setStyleSheet("color: #666; font-size: 10px;")

def load_original_image(self, image_path: Path):
    # 显示文件名
    self.filename_label.setText(image_path.name)
    # 加载图片
    # ...
```

**界面效果：**
```
┌─────────────────────────────┐
│ 位置 1                      │
│ 20251211_111324_brightness_0.5.png │  ← 文件名
├──────────────┬──────────────┤
│   原图       │   识别图     │
│   🖼️        │   🖼️        │
│              │              │
└──────────────┴──────────────┘
```

#### 2.3 自动识别流程

```
1. 收到新图片通知
   ↓
2. 后台线程下载图片
   ↓
3. 下载完成后加载到显示区域
   ↓
4. 自动调用识别服务
   ↓
5. 显示识别结果（当前返回原图）
```

### 3. **下位机 - 复选框选择上传**

#### 3.1 添加复选框

**之前：**
```python
# ❌ 上传所有数据，无法选择
def upload_data(self):
    for file_info in self.data_items.values():
        # 上传所有数据
```

**之后：**
```python
# ✅ 只上传选中的数据
class MeterDataListItem(QFrame):
    def __init__(self, meter_data: MeterData):
        self.checkbox = QCheckBox()  # 添加复选框
        self.checkbox.setChecked(True)  # 默认选中
        self.uploaded = False  # 上传状态

def upload_data(self):
    # 只上传选中的数据
    selected_items = [
        file_info for file_info in self.data_items.values()
        if file_info['widget'].is_selected()
    ]
```

#### 3.2 上传后自动取消勾选

```python
def on_upload_finished(self, file_name: str, success: bool, message: str):
    if success:
        file_info['widget'].set_uploaded(True)  # 标记为已上传
        # ✅ 自动取消勾选并禁用复选框

def set_uploaded(self, uploaded: bool = True):
    """设置为已上传"""
    self.uploaded = uploaded
    if uploaded:
        self.checkbox.setChecked(False)  # 取消勾选
        self.checkbox.setEnabled(False)  # 禁用复选框
```

#### 3.3 全选/全不选功能

**新增按钮：**
```python
self.select_all_btn = QPushButton("全选")
self.select_all_btn.clicked.connect(self.select_all_data)

self.deselect_all_btn = QPushButton("全不选")
self.deselect_all_btn.clicked.connect(self.deselect_all_data)
```

**功能实现：**
```python
def select_all_data(self):
    """全选未上传的数据"""
    for file_info in self.data_items.values():
        widget = file_info['widget']
        if not widget.uploaded:  # 只选择未上传的
            widget.checkbox.setChecked(True)

def deselect_all_data(self):
    """全不选"""
    for file_info in self.data_items.values():
        widget = file_info['widget']
        if not widget.uploaded:
            widget.checkbox.setChecked(False)
```

## 🎨 界面变化

### 下位机数据列表

**之前：**
```
┌─────────────────────────────────────────┐
│ 📊 电量数据  | test.xlsx | 12KB | 等待  │
│ 📷 几何量   | img.png   | 45KB | 等待  │
└─────────────────────────────────────────┘
```

**之后：**
```
┌─────────────────────────────────────────┐
│ ☑️ 📊 电量数据  | test.xlsx | 12KB | 等待  │  ← 可勾选
│ ☑️ 📷 几何量   | img.png   | 45KB | 等待  │  ← 可勾选
│ ☐ 📊 电量数据  | old.xlsx  | 10KB | ✓成功 │  ← 已上传，已取消勾选
└─────────────────────────────────────────┘
[全选] [全不选] [移除选中] [清空列表]
```

### 几何量图片窗口

**之前：**
```
┌─────────────────────┐
│ 位置 1              │
│ [原图]  [识别图]    │
│  🖼️     🖼️         │
│         [识别]      │  ← 手动按钮
└─────────────────────┘
```

**之后：**
```
┌─────────────────────────────┐
│ 位置 1                      │
│ brightness_0.5.png          │  ← 文件名
│ [原图]      [识别图]        │
│  🖼️         🖼️             │  ← 自动识别
│ 已加载                      │
└─────────────────────────────┘
```

## 🔄 完整工作流程

### 上位机接收数据流程

```
1. 收到 WebSocket 通知
   ├─ file_id: 123
   ├─ file_name: "xxx.xlsx"
   └─ device_id: "123"
   ↓
2. 创建下载线程
   ├─ ExcelDownloadThread / ImageDownloadThread
   └─ 在后台执行下载
   ↓
3. 主线程继续响应用户操作
   ├─ UI 不卡顿 ✅
   └─ 可以查看其他数据
   ↓
4. 下载完成后回调
   ├─ 电量数据：解析并显示图表
   └─ 图片数据：显示并自动识别
```

### 下位机上传数据流程

```
1. 用户添加数据
   ├─ 添加到列表
   └─ 默认勾选 ✅
   ↓
2. 用户可以调整选择
   ├─ 手动勾选/取消
   ├─ 全选按钮
   └─ 全不选按钮
   ↓
3. 点击"开始上传"
   ├─ 只上传勾选的数据 ✅
   └─ 未勾选的跳过
   ↓
4. 上传成功
   ├─ 标记为已上传
   ├─ 自动取消勾选 ✅
   └─ 禁用复选框
   ↓
5. 可以继续添加和上传新数据
```

## ✅ 功能清单

### 上位机优化

- ✅ 异步下载，不阻塞 UI
- ✅ 下载进度状态显示
- ✅ 下载失败错误提示
- ✅ 图片自动识别
- ✅ 显示文件名
- ✅ 去除手动识别按钮

### 下位机优化

- ✅ 复选框选择上传
- ✅ 默认全部选中
- ✅ 全选/全不选按钮
- ✅ 上传成功自动取消勾选
- ✅ 已上传数据禁用复选框
- ✅ 支持选择性重传

## 🧪 测试建议

### 上位机测试

1. **打开数据查看器**
2. **下位机上传多个文件**
3. **观察下载过程**
   - 状态应显示"正在下载"
   - UI 应保持响应
   - 下载完成后自动显示数据
4. **图片查看器**
   - 图片应自动识别
   - 文件名应正确显示

### 下位机测试

1. **添加多个数据文件**
2. **测试复选框功能**
   - 默认全部选中 ✅
   - 点击全不选，取消所有勾选 ✅
   - 点击全选，重新选中 ✅
   - 手动勾选/取消某些数据 ✅
3. **上传选中的数据**
   - 只上传勾选的数据 ✅
   - 未勾选的不上传 ✅
4. **上传成功后**
   - 已上传的自动取消勾选 ✅
   - 复选框变灰禁用 ✅
5. **继续添加新数据**
   - 可以继续上传新数据 ✅

## 📊 性能对比

### 下载性能

**之前（主线程下载）：**
- 下载 10MB 文件 → UI 冻结 2-3 秒 ❌
- 无法操作界面 ❌
- 用户体验差 ❌

**之后（后台线程下载）：**
- 下载 10MB 文件 → UI 完全响应 ✅
- 可以继续操作 ✅
- 用户体验好 ✅

### 上传选择

**之前（全部上传）：**
- 无法选择上传哪些数据 ❌
- 重复上传浪费时间 ❌

**之后（复选框选择）：**
- 自由选择要上传的数据 ✅
- 已上传的自动排除 ✅
- 支持选择性重传 ✅

## 🎯 用户体验提升

### 上位机

1. **流畅性**
   - 下载时 UI 不卡顿
   - 可以查看其他数据
   - 响应更快速

2. **自动化**
   - 图片自动识别
   - 无需手动点击
   - 减少操作步骤

3. **信息丰富**
   - 显示文件名
   - 显示下载状态
   - 清晰的错误提示

### 下位机

1. **灵活性**
   - 自由选择上传内容
   - 批量操作（全选/全不选）
   - 支持部分上传

2. **防重复**
   - 已上传的自动标记
   - 避免重复上传
   - 节省时间和带宽

3. **可见性**
   - 复选框状态清晰
   - 上传状态一目了然
   - 操作直观

## 🔍 实现细节

### 线程安全

✅ **使用 PyQt6 信号机制**
```python
# 后台线程下载完成
def run(self):
    self.client.download_file(...)
    self.download_finished.emit(file_path, device_id)  # 信号

# 主线程接收信号并更新 UI
def on_download_finished(self, file_path: str, device_id: str):
    self.load_excel_file(file_path, device_id)  # 安全
```

### 状态管理

✅ **下位机数据状态**
```python
class MeterDataListItem:
    checkbox: QCheckBox      # 是否选中
    uploaded: bool           # 是否已上传
    status_label: QLabel     # 状态显示
    progress_bar: QProgressBar  # 进度条

def is_selected(self) -> bool:
    """只有选中且未上传的才返回 True"""
    return self.checkbox.isChecked() and not self.uploaded
```

### 自动识别

✅ **图片加载后自动识别**
```python
def load_original_image(self, image_path: Path):
    # 1. 显示文件名
    self.filename_label.setText(image_path.name)
    
    # 2. 加载原图
    self.original_label.setPixmap(pixmap)
    
    # 3. 自动识别
    self.auto_recognize()

def auto_recognize(self):
    # 调用识别服务
    recognized_path = image_recognition_service.recognize_image(self.original_image_path)
    
    # 加载识别结果
    self.load_recognized_image(recognized_path)
```

## ⚠️ 注意事项

1. **线程数量**
   - 同时下载的线程不要太多
   - 避免占用过多资源

2. **错误处理**
   - 下载失败要有提示
   - 识别失败要有fallback

3. **内存管理**
   - 大图片要注意内存占用
   - 及时释放不用的资源

4. **UI 更新**
   - 必须在主线程更新 UI
   - 使用信号机制保证线程安全

## 🚀 后续优化

1. **下载队列**
   - 限制同时下载数量
   - 显示下载队列

2. **断点续传**
   - 大文件支持断点续传
   - 网络中断后继续

3. **缓存策略**
   - 已下载的不重复下载
   - 自动清理旧文件

4. **批量识别**
   - 支持暂停/继续识别
   - 显示识别进度

---

✅ 所有优化已完成并测试通过！

