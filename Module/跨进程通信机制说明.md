# 跨进程通信机制说明

**更新日期**: 2025-12-12

---

## 问题背景

### 发现的问题

当电量和几何量页面处于**前台显示状态**时，上位机接收到新数据通知、下载完成后，页面**没有自动更新**显示最新的缓存数据。

### 根本原因

上位机采用**多进程架构**：
- `connect_server` 进程：负责服务器连接和数据下载
- `main_gui` 进程：负责界面显示

**问题**：
- 下载管理器运行在 `connect_server` 进程
- 页面运行在 `main_gui` 进程
- **PyQt信号槽无法跨进程传递** ❌

```python
# ❌ 这种方式无法跨进程工作
download_manager.excel_data_ready.emit(file_path, device_id)
# 信号在 connect_server 进程发出
# 但页面在 main_gui 进程，接收不到
```

---

## 解决方案

使用**跨进程消息队列**机制（multiprocessing.Queue）进行进程间通信。

### 通信流程

```
connect_server 进程                main_gui 进程
    │                                  │
    ├─ 下载管理器                      ├─ 电量数据页面
    │    ↓                             │    ↑
    │  下载完成                         │  队列监听线程
    │    ↓                             │    ↑
    │  保存缓存                         │    │
    │    ↓                             │    │
    │  发送消息到队列 ────────────────> │  接收消息
    │    (ObjectQueueItem)             │    ↓
    │                                  │  调用 on_cache_data_ready()
    │                                  │    ↓
    │                                  │  更新显示
```

---

## 实现详解

### 1. 下载管理器添加队列支持

**文件**: `public/function/Cache/data_download_manager.py`

```python
class DataDownloadManager(QObject):
    def __init__(self):
        self.message_queue = None  # 跨进程消息队列
    
    def set_message_queue(self, queue):
        """设置跨进程消息队列"""
        self.message_queue = queue
    
    def _on_download_finished(self, data_type: str, file_path: str, device_id: str):
        """下载完成回调"""
        # 保存到缓存
        self._save_excel_to_cache(file_path, device_id)
        
        # 通过队列发送消息（跨进程）
        self._send_queue_message('excel_data_viewer', 'cache_data_ready', {
            'file_path': file_path,
            'device_id': device_id
        })
    
    def _send_queue_message(self, target: str, title: str, data: dict):
        """通过队列发送消息"""
        message = ObjectQueueItem(
            origin="download_manager",
            to=target,
            title=title,
            data=data,
            time=datetime.now().isoformat()
        )
        self.message_queue.put(message)
```

---

### 2. Client_server设置消息队列

**文件**: `Service/connect_server_service/index/Client_server.py`

```python
def connect_to_server(self):
    # ...
    # 设置下载管理器的客户端和消息队列
    download_manager.set_client(self)
    
    # 获取全局队列（跨进程）
    queue = global_setting.get_setting("queue", None)
    if queue:
        download_manager.set_message_queue(queue)
        logger.info("下载管理器消息队列已设置")
```

---

### 3. 页面队列监听线程

**文件**: `Module/excel_data_viewer/index/excel_viewer_window.py`

```python
class ExcelViewerQueueThread(MyQThread):
    """队列监听线程 - 监听跨进程消息"""
    
    def dosomething(self):
        """监听队列消息"""
        if not self.queue.empty():
            message = self.queue.get()
            if message.to == 'excel_data_viewer':
                if message.title == 'cache_data_ready':
                    # 收到缓存数据就绪通知
                    file_path = message.data['file_path']
                    device_id = message.data['device_id']
                    # 调用窗口的更新方法
                    self.window.on_cache_data_ready(file_path, device_id)
```

**文件**: `Module/image_data_viewer/index/image_viewer_window.py`

```python
class ImageViewerQueueThread(MyQThread):
    """队列监听线程 - 监听跨进程消息"""
    
    def dosomething(self):
        """监听队列消息"""
        if not self.queue.empty():
            message = self.queue.get()
            if message.to == 'image_data_viewer':
                if message.title == 'cache_data_ready':
                    # 收到缓存数据就绪通知
                    file_path = message.data['file_path']
                    device_id = message.data['device_id']
                    # 调用窗口的更新方法
                    self.window.on_cache_data_ready(file_path, device_id)
```

---

## 消息格式

### ObjectQueueItem 结构

```python
message = ObjectQueueItem(
    origin="download_manager",      # 消息来源
    to="excel_data_viewer",          # 目标（页面标识）
    title="cache_data_ready",        # 消息类型
    data={                           # 消息数据
        'file_path': '/path/to/file',
        'device_id': '12323'
    },
    time="2025-12-12T14:30:00"      # 时间戳
)
```

### 支持的消息类型

| 消息标题 | 目标 | 数据 | 说明 |
|---------|------|------|------|
| `cache_data_ready` | `excel_data_viewer` | `{file_path, device_id}` | 电量数据就绪 |
| `cache_data_ready` | `image_data_viewer` | `{file_path, device_id}` | 几何量数据就绪 |

---

## 完整数据流

### 场景：页面打开时接收新数据

```
1. 下位机发送数据 → 服务器
   ↓
2. 服务器WebSocket推送通知 → 上位机(connect_server进程)
   ↓
3. Client_server.on_ws_notification() 接收通知
   ↓
4. download_manager.handle_new_data_notification() 处理
   ↓
5. 创建下载线程，下载文件
   ↓
6. 下载完成 → _on_download_finished()
   ↓
7. 保存到缓存数据库
   ↓
8. 发送消息到队列 (multiprocessing.Queue)
   ↓
9. 消息跨进程传递到 main_gui 进程
   ↓
10. ExcelViewerQueueThread 从队列读取消息
   ↓
11. 调用 window.on_cache_data_ready()
   ↓
12. 页面从缓存读取数据
   ↓
13. 解析并更新显示
```

---

## 为什么需要队列？

### PyQt信号槽的限制

PyQt的信号槽机制基于**线程**，只能在**同一进程内**工作：

```python
# ✅ 同一进程内 - 可以工作
class Thread1(QThread):
    signal = pyqtSignal(str)

class MainWindow(QWidget):
    def __init__(self):
        thread = Thread1()
        thread.signal.connect(self.on_signal)  # ✅ 可以接收

# ❌ 跨进程 - 无法工作
# 进程A
download_manager.excel_data_ready.emit(data)

# 进程B
window.connect(download_manager.excel_data_ready)  # ❌ 接收不到
```

### multiprocessing.Queue的优势

```python
# ✅ 跨进程通信 - 可以工作
# 进程A
queue.put(message)  # 发送消息

# 进程B
message = queue.get()  # 接收消息
```

---

## 对比：信号 vs 队列

| 特性 | PyQt信号槽 | multiprocessing.Queue |
|------|-----------|----------------------|
| **使用范围** | 同一进程内 | **跨进程** ⭐ |
| **性能** | 快 | 稍慢（序列化开销） |
| **类型安全** | 强类型 | 需要手动检查 |
| **使用复杂度** | 简单 | 中等 |
| **适用场景** | 线程间通信 | **进程间通信** ⭐ |

---

## 架构图

### 多进程架构

```
┌─────────────────────────────────────────────────┐
│                  主进程                         │
│  ┌───────────┐         ┌──────────────┐        │
│  │ connect_  │         │  main_gui    │        │
│  │ server    │         │              │        │
│  │ 进程      │         │  进程        │        │
│  ├───────────┤         ├──────────────┤        │
│  │下载管理器 │         │ 电量数据页面 │        │
│  │     ↓     │         │      ↑       │        │
│  │ 下载文件  │         │ 队列监听线程 │        │
│  │     ↓     │         │      ↑       │        │
│  │ 保存缓存  │         │              │        │
│  │     ↓     │  Queue  │              │        │
│  │ 发消息 ───┼────────>│ 接收消息     │        │
│  └───────────┘         └──────────────┘        │
└─────────────────────────────────────────────────┘
```

### 消息流转

```
下载管理器(connect_server进程)
    ↓
ObjectQueueItem {
    to: "excel_data_viewer",
    title: "cache_data_ready",
    data: {file_path, device_id}
}
    ↓
multiprocessing.Queue
    ↓
ExcelViewerQueueThread(main_gui进程)
    ↓
window.on_cache_data_ready()
    ↓
更新显示
```

---

## 测试验证

### 测试步骤

1. **启动程序**，打开电量数据页面
2. **切换到日志选项卡**，观察日志
3. **下位机发送数据**
4. **观察日志输出**：
   ```
   [14:30:40] 收到新数据通知: xxx.xlsx, 设备: 12323
   [14:30:41] 开始加载数据...
   [14:30:42] 解析成功，共 3 个Sheet
   [14:30:43] ✅ 数据加载完成
   ```
5. **切换到实时数据选项卡**，确认数据已更新
6. **检查服务器日志**：
   ```
   [下载管理器] 下载完成: xxx.xlsx
   [下载管理器] 已发送队列消息到 excel_data_viewer
   [队列线程] 已触发电量数据页面更新
   ```

### 预期结果

- ✅ 日志显示接收到消息
- ✅ 页面自动刷新显示新数据
- ✅ 无需手动刷新

---

## 故障排查

### 问题1：页面仍然不更新

**检查**:
1. 查看服务器日志：`[下载管理器] 已发送队列消息到 excel_data_viewer`
2. 查看页面日志：`收到新数据通知`
3. 检查队列线程是否运行：`self.queue_thread.start()`

**解决**:
```python
# 确保队列线程已启动
self.queue_thread = ExcelViewerQueueThread("excel_queue", self)
queue = global_setting.get_setting("queue", None)
if queue:
    self.queue_thread.queue = queue
    self.queue_thread.start()  # ✅ 必须启动
```

### 问题2：消息队列未设置

**日志**:
```
[下载管理器] 消息队列未设置，无法发送通知
```

**检查**:
```python
# 在 Client_server.connect_to_server() 中
queue = global_setting.get_setting("queue", None)
if queue:
    download_manager.set_message_queue(queue)
```

**解决**: 确保 `global_setting` 中已设置 `queue`

### 问题3：消息被其他线程消费

**原因**: 多个线程从同一个队列读取，消息可能被其他线程取走

**解决**: 
- 确保消息的 `to` 字段正确
- 其他线程应该将不属于自己的消息放回队列

```python
# 正确的队列处理
if message.to == 'excel_data_viewer':
    # 处理消息
    ...
else:
    # 放回队列
    self.queue.put(message)
```

---

## 关键代码片段

### 下载管理器发送消息

```python
def _send_queue_message(self, target: str, title: str, data: dict):
    """通过队列发送消息（跨进程通信）"""
    if self.message_queue is None:
        logger.warning("消息队列未设置")
        return
    
    message = ObjectQueueItem(
        origin="download_manager",
        to=target,                    # 'excel_data_viewer' 或 'image_data_viewer'
        title=title,                  # 'cache_data_ready'
        data=data,                    # {'file_path': ..., 'device_id': ...}
        time=datetime.now().isoformat()
    )
    
    self.message_queue.put(message)
```

### 页面接收消息

```python
class ExcelViewerQueueThread(MyQThread):
    def dosomething(self):
        if not self.queue.empty():
            message = self.queue.get()
            
            # 检查消息目标
            if message.to == 'excel_data_viewer':
                if message.title == 'cache_data_ready':
                    file_path = message.data['file_path']
                    device_id = message.data['device_id']
                    
                    # 调用窗口更新方法
                    self.window.on_cache_data_ready(file_path, device_id)
```

---

## 优势对比

### 旧方案（信号槽）

```python
# ❌ 无法跨进程
download_manager.excel_data_ready.connect(window.on_cache_data_ready)
```

**问题**:
- 只能在同一进程内工作
- 页面关闭时接收不到消息

### 新方案（消息队列）✅

```python
# ✅ 可以跨进程
download_manager._send_queue_message('excel_data_viewer', 'cache_data_ready', data)
# 队列线程监听并处理
```

**优势**:
- ✅ 支持跨进程通信
- ✅ 消息持久化（队列中的消息不会丢失）
- ✅ 解耦合（发送者和接收者独立）
- ✅ 可靠性高

---

## 注意事项

### 1. 消息序列化

跨进程传递的对象必须可序列化：

```python
# ✅ 可以传递
data = {
    'file_path': '/path/to/file',  # 字符串
    'device_id': '12323'            # 字符串
}

# ❌ 不能直接传递
data = {
    'widget': some_qwidget,  # Qt对象无法序列化
    'file': open('file.txt')  # 文件句柄无法序列化
}
```

### 2. 消息目标标识

确保 `to` 字段正确：
- `'excel_data_viewer'` - 电量数据页面
- `'image_data_viewer'` - 几何量数据页面
- `'main_gui'` - 主窗口

### 3. 队列线程生命周期

```python
# 初始化时启动
self.queue_thread.start()

# 关闭时停止
def closeEvent(self, event):
    self.queue_thread.stop()
```

---

## 相关文档

- `Module/统一下载架构说明.md` - 下载架构说明
- `Module/进程间通信说明.md` - 已有的进程间通信文档（如果存在）

---

## 总结

通过使用 **multiprocessing.Queue** 实现跨进程通信，成功解决了页面无法接收下载完成通知的问题。

**核心机制**:
1. 下载管理器通过队列发送消息
2. 页面队列线程监听消息
3. 收到消息后调用页面更新方法
4. 页面从缓存读取并显示数据

**优势**:
- ✅ 支持跨进程通信
- ✅ 页面实时更新
- ✅ 可靠性高
- ✅ 易于扩展

**更新日期**: 2025-12-12

