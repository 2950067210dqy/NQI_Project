# 进程间通信实现说明

## 📋 问题背景

上位机系统中 `connect_server_service` 和 `main_gui` 是两个不同的子进程，当 `connect_server_service` 通过 WebSocket 接收到服务端的数据上传通知时，需要通过队列（Queue）将消息传递给 `main_gui` 进程中的数据查看器窗口。

## 🔄 通信流程

```
服务端 (NQI_Project_Server)
    ↓ WebSocket 通知
connect_server_service 进程
    ↓ Queue (ObjectQueueItem)
main_gui 进程
    ↓ 队列监听线程
数据查看器窗口 (ExcelDataViewerWindow / ImageDataViewerWindow)
```

## 📝 实现细节

### 1. 发送端：`connect_server_service` 进程

**文件：** `Service/connect_server_service/index/Client_server.py`

**修改内容：**
```python
def on_ws_notification(self, data: dict):
    """WebSocket 通知回调"""
    notification_type = data.get("type", "")
    
    if notification_type == "excel_upload":
        # 发送消息到 main_gui 进程的电量数据查看器
        queue = global_setting.get_setting("send_message_queue", None)
        if queue:
            queue.put(ObjectQueueItem(
                origin="connect_server",
                to="excel_data_viewer",           # 目标：电量数据查看器
                title="new_excel_data",           # 消息类型
                data=data,                        # 数据内容
                time=datetime.now().isoformat()
            ))
    
    elif notification_type == "image_upload":
        # 发送消息到 main_gui 进程的图片数据查看器
        queue = global_setting.get_setting("send_message_queue", None)
        if queue:
            queue.put(ObjectQueueItem(
                origin="connect_server",
                to="image_data_viewer",           # 目标：图片数据查看器
                title="new_image_data",           # 消息类型
                data=data,                        # 数据内容
                time=datetime.now().isoformat()
            ))
```

**添加的导入：**
```python
from datetime import datetime
from public.entity.queue.ObjectQueueItem import ObjectQueueItem
```

### 2. 接收端：数据查看器窗口

#### 2.1 电量数据查看器

**文件：** `Module/excel_data_viewer/index/excel_viewer_window.py`

**添加的队列监听线程类：**
```python
class ExcelViewerQueueThread(MyQThread):
    """队列监听线程"""
    
    def __init__(self, name, window):
        super().__init__(name)
        self.queue = None
        self.window = window  # 窗口引用
    
    def dosomething(self):
        if not self.queue.empty():
            try:
                message: ObjectQueueItem = self.queue.get()
            except Exception as e:
                logger.error(f"{self.name}发生错误{e}")
                return
            
            if message is not None and message.is_Empty():
                return
            
            # 只处理发给自己的消息
            if message is not None and isinstance(message, ObjectQueueItem) and message.to == 'excel_data_viewer':
                logger.info(f"电量数据查看器收到消息: {message.title}")
                
                match message.title:
                    case 'new_excel_data':
                        # 收到新的电量数据通知
                        data = message.data
                        if data and self.window:
                            # 通过信号发送到主线程更新 UI
                            self.window.update_data_signal.emit(data)
                    case _:
                        pass
            else:
                # 不是发给自己的消息，放回队列
                self.queue.put(message)
```

**窗口初始化修改：**
```python
def __init__(self, parent=None):
    super().__init__()
    # ... 其他初始化代码 ...
    
    # 队列监听线程
    self.queue_thread = ExcelViewerQueueThread("excel_viewer_queue_thread", self)
    queue = global_setting.get_setting("queue", None)
    if queue:
        self.queue_thread.queue = queue
        self.queue_thread.start()
        logger.info("电量数据查看器队列监听线程已启动")
```

**窗口关闭时停止线程：**
```python
def closeEvent(self, event):
    """窗口关闭事件"""
    if hasattr(self, 'queue_thread') and self.queue_thread:
        self.queue_thread.stop()
        logger.info("电量数据查看器队列监听线程已停止")
    super().closeEvent(event)
```

#### 2.2 几何量图片查看器

**文件：** `Module/image_data_viewer/index/image_viewer_window.py`

**添加的队列监听线程类：**
```python
class ImageViewerQueueThread(MyQThread):
    """队列监听线程"""
    
    def __init__(self, name, window):
        super().__init__(name)
        self.queue = None
        self.window = window  # 窗口引用
    
    def dosomething(self):
        if not self.queue.empty():
            try:
                message: ObjectQueueItem = self.queue.get()
            except Exception as e:
                logger.error(f"{self.name}发生错误{e}")
                return
            
            if message is not None and message.is_Empty():
                return
            
            # 只处理发给自己的消息
            if message is not None and isinstance(message, ObjectQueueItem) and message.to == 'image_data_viewer':
                logger.info(f"图片数据查看器收到消息: {message.title}")
                
                match message.title:
                    case 'new_image_data':
                        # 收到新的图片数据通知
                        data = message.data
                        if data and self.window:
                            # 通过信号发送到主线程更新 UI
                            self.window.update_data_signal.emit(data)
                    case _:
                        pass
            else:
                # 不是发给自己的消息，放回队列
                self.queue.put(message)
```

窗口初始化和关闭逻辑与电量数据查看器相同。

## 🔑 关键点说明

### 1. 队列获取

- **发送队列：** `global_setting.get_setting("send_message_queue")`
  - `connect_server_service` 使用此队列发送消息到 `main_gui`

- **接收队列：** `global_setting.get_setting("queue")`
  - `main_gui` 和其窗口使用此队列接收消息

### 2. 消息格式

```python
ObjectQueueItem(
    origin="connect_server",        # 来源：connect_server_service
    to="excel_data_viewer",         # 目标：窗口标识符
    title="new_excel_data",         # 消息类型
    data={...},                     # 数据内容
    time="2025-12-11T12:00:00"     # 时间戳
)
```

### 3. 消息目标标识符

- `excel_data_viewer` - 电量数据查看器
- `image_data_viewer` - 图片数据查看器

### 4. 消息类型

- `new_excel_data` - 新的电量数据通知
- `new_image_data` - 新的图片数据通知

### 5. 线程安全

- 队列监听线程在后台运行，从队列读取消息
- 使用 PyQt6 的信号机制（`update_data_signal.emit(data)`）将消息传递到主线程
- 确保 UI 更新在主线程中进行，避免线程安全问题

## 📊 数据流示例

### 电量数据上传流程

1. **下位机** 上传 Excel 文件到 **服务端**
2. **服务端** 通过 WebSocket 发送通知给 **connect_server_service**
   ```json
   {
       "type": "excel_upload",
       "device_id": "123",
       "file_name": "20251211_094711_TA3310三相表数据.xlsx",
       "file_size": 12345,
       "timestamp": "2025-12-11T09:47:11"
   }
   ```
3. **connect_server_service** 的 `on_ws_notification` 方法接收到通知
4. 将通知封装成 `ObjectQueueItem` 并放入 `send_message_queue`
5. **main_gui** 进程中的 **电量数据查看器** 队列监听线程读取消息
6. 通过 `update_data_signal` 信号发送到主线程
7. 窗口的 `on_new_data_received` 方法处理数据并更新 UI

### 图片数据上传流程

流程与电量数据类似，只是：
- 消息目标为 `image_data_viewer`
- 消息类型为 `new_image_data`
- 处理的窗口是 **图片数据查看器**

## 🧪 测试验证

### 1. 启动系统

```bash
# 启动上位机
python main.py
```

### 2. 连接服务器

在上位机界面中连接到服务器，确保 WebSocket 连接成功。

### 3. 打开数据查看器

从菜单打开：
- 数据监控 -> 电量数据查看器
- 数据监控 -> 几何量图片查看器

### 4. 下位机上传数据

使用下位机上传数据，观察：
- `connect_server_service` 日志：`[WebSocket] 收到xxx数据上传通知`
- `connect_server_service` 日志：`已发送xxx数据通知到队列`
- 查看器窗口日志：`xxx数据查看器收到消息: new_xxx_data`
- 查看器窗口显示通知对话框或更新 UI

## 🔍 调试技巧

### 查看队列消息

在队列监听线程的 `dosomething` 方法中添加日志：

```python
def dosomething(self):
    if not self.queue.empty():
        logger.debug(f"队列中有消息，队列大小: {self.queue.qsize()}")
        # ... 处理消息 ...
```

### 检查消息是否被正确放入队列

在 `Client_server.py` 的 `on_ws_notification` 方法中：

```python
queue = global_setting.get_setting("send_message_queue", None)
if queue:
    logger.info(f"当前队列大小: {queue.qsize()}")
    queue.put(...)
    logger.info(f"消息已放入队列，新队列大小: {queue.qsize()}")
else:
    logger.error("队列不存在！")
```

### 检查消息是否被正确接收

在窗口的 `on_new_data_received` 方法中：

```python
def on_new_data_received(self, data: dict):
    logger.info(f"收到新数据通知: {data}")
    # ... 处理数据 ...
```

## ⚠️ 注意事项

1. **队列只读不写**
   - 窗口的队列监听线程只从 `queue` 读取消息
   - 如果需要回复消息，应该使用 `send_message_queue`

2. **消息放回队列**
   - 如果消息不是发给自己的（`message.to` 不匹配），必须放回队列
   - 避免丢失其他组件的消息

3. **线程安全**
   - 所有 UI 更新必须在主线程中进行
   - 使用 PyQt6 的信号机制确保线程安全

4. **资源清理**
   - 窗口关闭时必须停止队列监听线程
   - 避免线程泄漏和资源占用

## 🚀 后续扩展

如果需要添加新的数据查看器，遵循以下步骤：

1. 在窗口类中添加队列监听线程类（参考现有实现）
2. 在窗口初始化时启动队列监听线程
3. 在窗口关闭时停止队列监听线程
4. 在 `Client_server.py` 的 `on_ws_notification` 中添加相应的消息发送逻辑
5. 定义新的消息目标标识符和消息类型

## 📞 问题排查

### 窗口没有收到通知

检查：
1. WebSocket 连接是否正常
2. `connect_server_service` 是否正确发送消息到队列
3. 窗口的队列监听线程是否启动
4. 消息的 `to` 字段是否正确
5. 队列是否正确获取（`global_setting.get_setting("queue")`）

### 程序卡死或崩溃

检查：
1. 队列监听线程是否正确停止
2. 是否在非主线程更新 UI
3. 消息处理是否有异常未捕获

---

✅ 所有修改已完成并测试通过！

